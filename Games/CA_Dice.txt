// SPDX-License-Identifier: MIT

pragma solidity ^0.8.23;

import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface IWalletDetector {
    function isWallet(address _addr) external  view returns (bool); 
}

contract CA_DicePool {
    address public token;
    uint256 public betAmount;
    address public creator;
    address public constant WalletDetector = 0x3f76562685E9Cd18ba88C062bBC5999D78275734;
    address public constant FEE_RECEIVER = 0xAD0b565C521cD2c7d117436ec4565f34eEEc5D78;
    uint256 public constant ROLL_FEE = 0.00009 ether;
    uint256 private random = block.timestamp;
    mapping(uint256 => bool) public hasUsed;

    Record[] public records;
    mapping(uint256 => Record) public orders;
    mapping(address => Record[]) public userRecords; 
    mapping(uint256 => bool) public isUsed;
    uint256 public lastBlock = 0;

    enum Choice { Less, Greater}

    event DiceRolled(uint256 timestamp, address player, uint8 diceOutcome, uint256 payout, bool isWin, uint256 order, uint256 multiple);
    event Deposit(uint256 timestamp, address indexed user, address token, uint256 amount);
    event Withdraw(uint256 timestamp, address indexed user, address token, uint256 amount);

    struct Record {
        uint256 timestamp;
        address player;
        uint8 diceOutcome; 
        uint256 payout;
        bool isWin;
        uint256 order;
        uint256 multiple;
    }

    constructor(address _token, uint256 _betAmount, address _creator) {
        token = _token;
        betAmount = _betAmount;
        creator = _creator;
    }

    function deposit(uint256 amount) external {
        require(msg.sender == creator, "No permission");
        require(amount > 0, "Error param");
        IERC20(token).transferFrom(msg.sender, address(this), amount);
        emit Deposit(block.timestamp, msg.sender, token, amount);
    }

    function withdraw(uint256 amount) external {
        require(msg.sender == creator, "No permission");
        require(amount > 0, "Error param");

        uint256 _balance = IERC20(token).balanceOf(address(this));
        require(_balance >= amount, "Insufficient balance");
        IERC20(token).transfer(msg.sender, amount);
        emit Withdraw(block.timestamp, msg.sender, token, amount);
    }

    function generateRandom(address sender) private returns(uint8) {
        uint256 _balance = IERC20(token).balanceOf(address(this));
        random += _balance % 7111;
        return uint8(uint256(keccak256(abi.encodePacked(block.timestamp, sender, block.gaslimit, random))) / random);
    }

   
    function rollDice(Choice choice, uint256 multiple, uint256 order) external payable {
        require(IWalletDetector(WalletDetector).isWallet(msg.sender), "msg.sender must be wallet");
        require(!hasUsed[order], "Order has used");
        require(multiple == 1 || multiple == 3 || multiple == 7 || multiple == 10, "invalid multiple");
        require(msg.value >= ROLL_FEE, "Fee error");
        

        // mark order
        hasUsed[order] = true;

        payable(FEE_RECEIVER).transfer(msg.value);

        require(block.number != lastBlock, "Block error");
        lastBlock = block.number;

        IERC20(token).transferFrom(msg.sender, address(this), betAmount * multiple);
        uint8 randNum = generateRandom(msg.sender);

        bool isWin = (randNum % 2) == 0;
        uint8 diceOutcome = 1;
        if (Choice.Less == choice) {
            if (isWin == true) {
                diceOutcome = 1 + randNum % 3;
            }
            else {
                diceOutcome = 4 + randNum % 3;
            }
        }
        else {
            if (isWin == true) {
                diceOutcome = 4 + randNum % 3;
            }
            else {
                diceOutcome = 1 + randNum % 3;
            }
        }

        uint256 payout = 0;
        if (isWin) {
            payout = betAmount * multiple * 2 * 95 / 100; 
            IERC20(token).transfer(msg.sender, payout);
        }

        Record memory record = Record({
            timestamp: block.timestamp, 
            player: msg.sender,
            diceOutcome: diceOutcome,
            payout: payout,
            isWin: isWin,
            order: order,
            multiple: multiple
        });

        records.push(record);
        orders[order] = record;
        userRecords[msg.sender].push(record);
        emit DiceRolled(block.timestamp, msg.sender, diceOutcome, payout, isWin, order, multiple);
    }

    function getRecordsLength() public view returns(uint256) {
        return records.length;
    }

    function getUserRecordsLength(address account) public view returns(uint256) {
        return userRecords[account].length;
    }

    function getUserRecordByRange(address account, uint256 start, uint256 end) public view returns(Record[] memory) {
        require(start >= 0 && end <= userRecords[account].length && start <= end, "Invalid range");
        Record[] memory diceBetsRange = new Record[](end - start);
        for (uint256 i = start; i < end; i++) {
            diceBetsRange[i - start] = userRecords[account][i];
        }
        return diceBetsRange;
    } 

    function getRecords30Last() public view returns(Record [] memory) {
        if (records.length <= 30) {
            return records;
        } 
        
        Record [] memory slicedRecords = new Record[](30);
        uint256 start = records.length - 30;
        for (uint256 i = start; i < records.length; i++) {
            slicedRecords[i - start] = records[i];
        }
        return slicedRecords;
    }
}

contract CA_DiceFactory {
    mapping(address => DiceBet[]) public userDiceBets;
    DiceBet[] public diceBets;

    struct DiceBet {
        address poolAddr;
        address betToken;
        uint256 betAmount;
        address creator;
    }

    event DiceCreated(uint256 indexed timestamp, address indexed token, address poolAddr, uint256 betAmount, address creator);

    function DiceCreate(address token, uint256 betAmount) public {
        bytes memory deploymentData = abi.encodePacked(
            type(CA_DicePool).creationCode,
            abi.encode(token, betAmount, msg.sender)
        );
        bytes32 salt = keccak256(abi.encodePacked(token, betAmount, msg.sender, diceBets.length));
        address addr;
        assembly {
            addr := create2(
            0x0, add(0x20, deploymentData), mload(deploymentData), salt
            )
        }
        require(addr != address(0), "Failed on create pool");

        DiceBet memory diceBet = DiceBet({poolAddr: addr, betToken: token, betAmount: betAmount, creator: msg.sender});
        userDiceBets[msg.sender].push(diceBet);
        diceBets.push(diceBet);
        emit DiceCreated(block.timestamp, token, addr, betAmount, msg.sender);
    }

    function getDiceBetsLength() public view returns(uint256) {
        return diceBets.length;
    }

    function getDiceBetsByRange(uint256 start, uint256 end) public view returns(DiceBet[] memory) {
        require(start >= 0 && end <= diceBets.length && start <= end, "Invalid range");
        DiceBet[] memory diceBetsRange = new DiceBet[](end - start);
        for (uint256 i = start; i < end; i++) {
            diceBetsRange[i - start] = diceBets[i];
        }
        return diceBetsRange;
    } 

    function getUserDiceBetsLength(address account) public view returns(uint256) {
        return userDiceBets[account].length;
    }

    function getUserDiceBetsByRange(address account, uint256 start, uint256 end) public view returns(DiceBet[] memory) {
        require(start >= 0 && end <= userDiceBets[account].length && start <= end, "Invalid range");
        DiceBet[] memory diceBetsRange = new DiceBet[](end - start);
        for (uint256 i = start; i < end; i++) {
            diceBetsRange[i - start] = userDiceBets[account][i];
        }
        return diceBetsRange;
    }
}